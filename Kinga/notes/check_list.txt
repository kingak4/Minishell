ğŸ”§ Kompilacja i Makefile
 Makefile zawiera targety: NAME, all, clean, fclean, re

 Kompiluje siÄ™ poprawnie: bez bÅ‚Ä™dÃ³w, bez ostrzeÅ¼eÅ„ (-Wall -Wextra -Werror)

 make nie wykonuje przelinkowania (czyli nie robi nic, jeÅ›li wszystko juÅ¼ jest zbudowane)

 Nie ma wyciekÃ³w pamiÄ™ci (sprawdÅº valgrind, leaks)

 Nie ma uÅ¼ycia zakazanych funkcji ani aliasÃ³w

ğŸŸ¢ Podstawowa funkcjonalnoÅ›Ä‡
 Shell wyÅ›wietla prompt po uruchomieniu i po kaÅ¼dym wykonaniu komendy

 Shell zapamiÄ™tuje historiÄ™ (dziaÅ‚a strzaÅ‚ka w gÃ³rÄ™ i w dÃ³Å‚)

 Komendy moÅ¼na uruchamiaÄ‡ z:

 absolutnÄ… Å›cieÅ¼kÄ… (np. /bin/ls)

 relatywnÄ… Å›cieÅ¼kÄ… (np. ./my_script)

 bez Å›cieÅ¼ki (jeÅ›li jest ustawiona zmienna PATH)

 Po usuniÄ™ciu PATH komendy przestajÄ… dziaÅ‚aÄ‡

 DziaÅ‚a interpretacja zmiennych Å›rodowiskowych ($USER, $HOME, itp.)

 DziaÅ‚a $? â€” zwraca kod wyjÅ›cia poprzedniej komendy

 ObsÅ‚ugiwane sÄ… komendy wbudowane (builtins):

 echo z opcjÄ… -n

 cd z relatywnÄ… i absolutnÄ… Å›cieÅ¼kÄ…, takÅ¼e . i ..

 pwd

 export (tworzenie i nadpisywanie zmiennych)

 unset (usuwanie zmiennych)

 env (wypisuje Å›rodowisko)

 exit z i bez argumentÃ³w

 Shell nie wykonuje komend, jeÅ›li uÅ¼ytkownik wpisze pustÄ… liniÄ™ lub samÄ… spacjÄ™

 Shell uÅ¼ywa maksymalnie jednej zmiennej globalnej do sygnaÅ‚Ã³w (np. g_exit_status)

ğŸ“ ObsÅ‚uga cudzysÅ‚owÃ³w
 Pojedyncze cudzysÅ‚owy '...' â€“ wszystko traktowane dosÅ‚ownie (np. echo '$USER' wypisuje $USER)

 PodwÃ³jne cudzysÅ‚owy "..." â€“ interpretowane zmienne (echo "$USER" wypisuje wartoÅ›Ä‡)

 NiezamkniÄ™te cudzysÅ‚owy powodujÄ… bÅ‚Ä…d (a nie segfault ani dziwne zachowanie)

 Shell nie obsÅ‚uguje nieopisanych znakÃ³w specjalnych: \, ;, itp.

â¡ï¸ Redirekcje
 > â€“ przekierowanie wyjÅ›cia do pliku (nadpisanie)

 >> â€“ przekierowanie wyjÅ›cia do pliku (dopisywanie)

 < â€“ wczytanie danych z pliku

 << â€“ heredoc dziaÅ‚a poprawnie (nie musi zapisywaÄ‡ do historii)

 W przypadku nieprawidÅ‚owej skÅ‚adni redirekcji shell nie crashuje i wypisuje bÅ‚Ä…d

ğŸ§ª Pipeâ€™y
 Polecenia poÅ‚Ä…czone | dziaÅ‚ajÄ… poprawnie: cat file | grep x | wc

 BÅ‚Ä™dne komendy w Å›rodku pipeâ€™a (np. ls nieistnieje | grep x) nie wywalajÄ… programu

 MoÅ¼na Å‚Ä…czyÄ‡ pipeâ€™y i redirekcje (cat < file | grep x > out)

 DziaÅ‚a przypadek cat | cat | ls

âš ï¸ ObsÅ‚uga sygnaÅ‚Ã³w
 Ctrl-C na pustym promptcie: wyÅ›wietla nowÄ… liniÄ™ i nowy prompt

 Ctrl-C po wpisaniu komendy: czyszczony bufor, nic nie wykonuje siÄ™

 Ctrl-D na pustym promptcie: koÅ„czy minishell

 Ctrl-D po wpisaniu tekstu: nic siÄ™ nie dzieje

 Ctrl-\ w kaÅ¼dej sytuacji: nic siÄ™ nie dzieje

 ObsÅ‚uga Ctrl-C, Ctrl-D, Ctrl-\ dziaÅ‚a rÃ³wnieÅ¼ przy uruchomieniu komend blokujÄ…cych (cat, grep)

ğŸ’² Zmienne Å›rodowiskowe
 echo $VAR â€“ zmienne sÄ… rozwijane do wartoÅ›ci

 echo "$VAR" â€“ rÃ³wnieÅ¼ rozwija do wartoÅ›ci

 echo '$VAR' â€“ wypisuje dosÅ‚ownie $VAR

 JeÅ›li USER nie istnieje â€“ shell potrafi go ustawiÄ‡

ğŸ­ Zachowanie interaktywne i testy skrajne
 Bufor jest czyszczony po Ctrl-C + Enter (nic siÄ™ nie wykonuje)

 Shell nie zawiesza siÄ™ przy bÅ‚Ä™dnych poleceniach (sdgshgshg)

 Shell dziaÅ‚a stabilnie przy dÅ‚ugich liniach z wieloma argumentami

 MoÅ¼liwa jest nawigacja po historii (strzaÅ‚ki gÃ³ra/dÃ³Å‚)

 MoÅ¼na powtarzaÄ‡ wczeÅ›niejsze komendy z historii
 
 skrÃ³t w Visual Studio aby poprawiÄ‡ kod zgodnie z norminette Control+shift+I


ğŸ”¹ 1. Sanity check na wejÅ›ciu
 Czy linia wejÅ›ciowa nie jest pusta po trimie (nie liczÄ…c spacji/tabÃ³w)?

 Czy wszystkie nawiasy cudzysÅ‚owu sÄ… domkniÄ™te (symetria ', ").

 Czy nie ma nieprawidÅ‚owych zakoÅ„czeÅ„ typu:

|, >, < bez argumentu po nich

||, >>>, ><, <| (nieobsÅ‚ugiwane przez minishella)

 Czy liczba metaznakÃ³w jest sensowna (|, <, >, <<, >>)

ğŸ”¹ 2. Tokenizacja (ft_split_mini)
 Czy poprawnie rozdzielasz string na tokeny, uwzglÄ™dniajÄ…c:

pojedyncze ' ' (nie interpretuj metaznakÃ³w, nawet $)

podwÃ³jne " (interpretuj $, ale nie inne metaznaki)

ignorowanie spacji i tabÃ³w miÄ™dzy tokenami

 Czy traktujesz operatory redirekcji (<, >, <<, >>) i pipe (|) jako osobne tokeny?

 Czy tokeny sÄ… poprawnie czyszczone z cudzysÅ‚owÃ³w (przechowujesz je osobno tylko jeÅ›li trzeba)?

ğŸ”¹ 3. Rozpoznanie redirekcji i ich argumentÃ³w
Dla kaÅ¼dego polecenia:

 Czy redirekcje majÄ… argument (plik/nazwa) bezpoÅ›rednio po sobie?

 Czy argumenty redirekcji nie sÄ… pipeâ€™ami lub innymi operatorami?

 Czy nie ma wielu redirekcji tego samego typu bez sensu (np. cmd > a > b)?

 Czy << limiter dziaÅ‚a bez interpretacji $ w limiterze?

 Czy << z pustym limitem nie powoduje awarii?

ğŸ”¹ 4. Rozdzielenie poleceÅ„ wzglÄ™dem pipe
 Czy kaÅ¼de polecenie przed i po | istnieje i zawiera coÅ› do wykonania?

 Czy tworzysz strukturÄ™ tablicy t_cmd[], gdzie kaÅ¼dy t_cmd to jedno polecenie miÄ™dzy |?

 Czy dla kaÅ¼dego t_cmd przypisujesz:

jego argv (komenda i argumenty)

jego redirekcje (typ + plik docelowy)

info, czy ma pipe do nastÄ™pnego (has_pipe)

ğŸ”¹ 5. Rozpoznanie built-in vs external
Dla kaÅ¼dego t_cmd:

 Czy sprawdzasz, czy komenda to built-in (echo, cd, pwd, export, unset, env, exit)?

 Czy odpowiednio zaznaczasz to w strukturze (cmd->builtin = BUILTIN_ECHO lub NONE)?

ğŸ”¹ 6. Ekspansja zmiennych Å›rodowiskowych
 Czy wykonujesz ekspansjÄ™ $VAR wewnÄ…trz cudzysÅ‚owÃ³w "..." i na zewnÄ…trz, ale nie wewnÄ…trz '...'?

 Czy $? zostaje zamienione na kod wyjÅ›cia poprzedniego polecenia?

 Czy brakujÄ…ce zmienne $NIEISTNIEJE sÄ… zamieniane na pusty string?

ğŸ”¹ 7. Finalna walidacja kaÅ¼dego t_cmd przed przekazaniem do egzekucji
Dla kaÅ¼dego t_cmd:

 Czy argv[0] istnieje? (czy komenda nie jest pusta)

 Czy nie ma bÅ‚Ä™dnych redirekcji (np. brak pliku do redir)?

 Czy wszystkie tokeny sÄ… â€czysteâ€ (czyli bez Å›mieci typu niezamkniÄ™te cudzysÅ‚owy, pipe'y w argumentach itp.)?

 Czy nie przekazujesz pustych tablic argv do execve?

 ğŸ” KolejnoÅ›Ä‡ dziaÅ‚ania parsera:
Czy linia pusta?

Czy cudzysÅ‚owy sÄ… domkniÄ™te?

Czy sÄ… nieprawidÅ‚owe sekwencje redirekcji?

Czy redirekcje majÄ… cel?

Czy pipeâ€™y sÄ… poprawnie uÅ¼yte?

Dopiero potem: tokenizacja i analiza skÅ‚adniowa