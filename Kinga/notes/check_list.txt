ğŸ”§ Kompilacja i Makefile
 Makefile zawiera targety: NAME, all, clean, fclean, re

 Kompiluje siÄ™ poprawnie: bez bÅ‚Ä™dÃ³w, bez ostrzeÅ¼eÅ„ (-Wall -Wextra -Werror)

 make nie wykonuje przelinkowania (czyli nie robi nic, jeÅ›li wszystko juÅ¼ jest zbudowane)

 Nie ma wyciekÃ³w pamiÄ™ci (sprawdÅº valgrind, leaks)

 Nie ma uÅ¼ycia zakazanych funkcji ani aliasÃ³w

ğŸŸ¢ Podstawowa funkcjonalnoÅ›Ä‡
 Shell wyÅ›wietla prompt po uruchomieniu i po kaÅ¼dym wykonaniu komendy

 Shell zapamiÄ™tuje historiÄ™ (dziaÅ‚a strzaÅ‚ka w gÃ³rÄ™ i w dÃ³Å‚)

 Komendy moÅ¼na uruchamiaÄ‡ z:

 absolutnÄ… Å›cieÅ¼kÄ… (np. /bin/ls)

 relatywnÄ… Å›cieÅ¼kÄ… (np. ./my_script)

 bez Å›cieÅ¼ki (jeÅ›li jest ustawiona zmienna PATH)

 Po usuniÄ™ciu PATH komendy przestajÄ… dziaÅ‚aÄ‡

 DziaÅ‚a interpretacja zmiennych Å›rodowiskowych ($USER, $HOME, itp.)

 DziaÅ‚a $? â€” zwraca kod wyjÅ›cia poprzedniej komendy

 ObsÅ‚ugiwane sÄ… komendy wbudowane (builtins):

 echo z opcjÄ… -n

 cd z relatywnÄ… i absolutnÄ… Å›cieÅ¼kÄ…, takÅ¼e . i ..

 pwd

 export (tworzenie i nadpisywanie zmiennych)

 unset (usuwanie zmiennych)

 env (wypisuje Å›rodowisko)

 exit z i bez argumentÃ³w

 Shell nie wykonuje komend, jeÅ›li uÅ¼ytkownik wpisze pustÄ… liniÄ™ lub samÄ… spacjÄ™

 Shell uÅ¼ywa maksymalnie jednej zmiennej globalnej do sygnaÅ‚Ã³w (np. g_exit_status)

ğŸ“ ObsÅ‚uga cudzysÅ‚owÃ³w
 Pojedyncze cudzysÅ‚owy '...' â€“ wszystko traktowane dosÅ‚ownie (np. echo '$USER' wypisuje $USER)

 PodwÃ³jne cudzysÅ‚owy "..." â€“ interpretowane zmienne (echo "$USER" wypisuje wartoÅ›Ä‡)

 NiezamkniÄ™te cudzysÅ‚owy powodujÄ… bÅ‚Ä…d (a nie segfault ani dziwne zachowanie)

 Shell nie obsÅ‚uguje nieopisanych znakÃ³w specjalnych: \, ;, itp.

â¡ï¸ Redirekcje
 > â€“ przekierowanie wyjÅ›cia do pliku (nadpisanie)

 >> â€“ przekierowanie wyjÅ›cia do pliku (dopisywanie)

 < â€“ wczytanie danych z pliku

 << â€“ heredoc dziaÅ‚a poprawnie (nie musi zapisywaÄ‡ do historii)

 W przypadku nieprawidÅ‚owej skÅ‚adni redirekcji shell nie crashuje i wypisuje bÅ‚Ä…d

ğŸ§ª Pipeâ€™y
 Polecenia poÅ‚Ä…czone | dziaÅ‚ajÄ… poprawnie: cat file | grep x | wc

 BÅ‚Ä™dne komendy w Å›rodku pipeâ€™a (np. ls nieistnieje | grep x) nie wywalajÄ… programu

 MoÅ¼na Å‚Ä…czyÄ‡ pipeâ€™y i redirekcje (cat < file | grep x > out)

 DziaÅ‚a przypadek cat | cat | ls

âš ï¸ ObsÅ‚uga sygnaÅ‚Ã³w
 Ctrl-C na pustym promptcie: wyÅ›wietla nowÄ… liniÄ™ i nowy prompt

 Ctrl-C po wpisaniu komendy: czyszczony bufor, nic nie wykonuje siÄ™

 Ctrl-D na pustym promptcie: koÅ„czy minishell

 Ctrl-D po wpisaniu tekstu: nic siÄ™ nie dzieje

 Ctrl-\ w kaÅ¼dej sytuacji: nic siÄ™ nie dzieje

 ObsÅ‚uga Ctrl-C, Ctrl-D, Ctrl-\ dziaÅ‚a rÃ³wnieÅ¼ przy uruchomieniu komend blokujÄ…cych (cat, grep)

ğŸ’² Zmienne Å›rodowiskowe
 echo $VAR â€“ zmienne sÄ… rozwijane do wartoÅ›ci

 echo "$VAR" â€“ rÃ³wnieÅ¼ rozwija do wartoÅ›ci

 echo '$VAR' â€“ wypisuje dosÅ‚ownie $VAR

 JeÅ›li USER nie istnieje â€“ shell potrafi go ustawiÄ‡

ğŸ­ Zachowanie interaktywne i testy skrajne
 Bufor jest czyszczony po Ctrl-C + Enter (nic siÄ™ nie wykonuje)

 Shell nie zawiesza siÄ™ przy bÅ‚Ä™dnych poleceniach (sdgshgshg)

 Shell dziaÅ‚a stabilnie przy dÅ‚ugich liniach z wieloma argumentami

 MoÅ¼liwa jest nawigacja po historii (strzaÅ‚ki gÃ³ra/dÃ³Å‚)

 MoÅ¼na powtarzaÄ‡ wczeÅ›niejsze komendy z historii
 
 skrÃ³t w Visual Studio aby poprawiÄ‡ kod zgodnie z norminette Control+shift+I


