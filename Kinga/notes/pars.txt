PodzieliÄ‡ wejÅ›ciowy string na tokeny: sÅ‚owa, operatory (|, >, <, >>, <<), separatory ( , \t) i specjalne elementy (", ', $).

âœ… KLUCZOWE ZASADY:
Token to nie to samo co sÅ‚owo â€“ token moÅ¼e byÄ‡ np. operator redirekcji >>, pojedyncze sÅ‚owo, string w cudzysÅ‚owie itp.

Szanuj cudzysÅ‚owy:

" pozwala na ekspansjÄ™ zmiennych ("$HOME" â†’ /home/kinga),

' literalnie â€“ bez ekspansji ('$HOME' â†’ $HOME).

Zadbaj o specjalne znaki:

|, >, >>, <, << muszÄ… byÄ‡ osobnymi tokenami.

Zignoruj spacje i taby jako delimitery tokenÃ³w, ale nie wewnÄ…trz cudzysÅ‚owÃ³w.

Zadbaj o escapy (\) â€“ tylko w kontekÅ›cie cudzysÅ‚owÃ³w.
ğŸ“š CZÄ˜ÅšÄ† 2: PARSING
ğŸ¯ CEL:
Na podstawie listy tokenÃ³w zbudowaÄ‡ strukturÄ™ opisujÄ…cÄ… polecenia do wykonania, z informacjÄ… o:

poleceniu i jego argumentach,

redirekcjach,

heredocach,

pipeâ€™ach.

âœ… KLUCZOWE ZASADY:
Wykryj granice komend â€“ pipe (|) oddziela polecenia.

KaÅ¼da komenda ma swojÄ… strukturÄ™ np.:
Argumenty zbieraj po kolei â€“ po poleceniu czytaj wszystkie T_WORD, dopÃ³ki nie trafisz na pipe lub koniec.

Redirekcje przetwarzaj parami: > musi byÄ‡ zaraz po nim T_WORD (nazwa pliku).

Waliduj skÅ‚adniÄ™ â€“ wykrywaj bÅ‚Ä™dy typu:

| ls (pipe na poczÄ…tku),

cat < (brak pliku po redirekcji),

ls || grep (podwÃ³jny pipe),

> bez pliku.
ğŸ“Œ DOBRE NAWYKI I STRATEGIE
ğŸ§± 1. Lexer i Parser jako osobne moduÅ‚y
Lexer = char *line â†’ t_token *tokens

Parser = t_token *tokens â†’ t_cmd **commands

ğŸ§ª 2. Zbuduj testy jednostkowe
Testuj lexera i parsera niezaleÅ¼nie. PrzykÅ‚ady wejÅ›Ä‡:

echo "hello world" > out.txt

cat < in.txt | grep hi | wc -l

echo '$USER' >> out.txt

ğŸ’¥ 3. ObsÅ‚uÅ¼ edge-case'y
Puste inputy.

NiezamkniÄ™te cudzysÅ‚owy.

Redirekcje bez pliku.

Pipe na koÅ„cu.

ğŸ§  4. Parsuj z automatu (automatyzacja)
Lexer dziaÅ‚a jak automat: stan zwykÅ‚y â†’ w cudzysÅ‚owie â†’ po operatorze itp.

ğŸ”„ SCHEMAT DZIAÅANIA:
WejÅ›cie: "cat file.txt | grep 'hello' > out.txt"

Lexer:

T_WORD: cat

T_WORD: file.txt

T_PIPE: |

T_WORD: grep

T_WORD: hello

T_REDIRECT_OUT: >

T_WORD: out.txt

Parser:

2 komendy: cat file.txt i grep hello

redirekcja > na drugiej komendzie


âš ï¸ EDGE CASE'Y â€“ LEXING
1. Spacje i taby
ls -l

echo hello

echo " a b "

Lexer nie moÅ¼e tworzyÄ‡ pustych tokenÃ³w, nie moÅ¼e zgubiÄ‡ argumentÃ³w przez wielokrotne spacje.

2. NiezamkniÄ™te cudzysÅ‚owy
echo "Hello

echo 'Hello

Musisz wykryÄ‡ bÅ‚Ä…d i zasygnalizowaÄ‡ go uÅ¼ytkownikowi, np. syntax error: unclosed quote.

3. ZagnieÅ¼dÅ¼one lub mieszane cudzysÅ‚owy
echo "'hi'"

echo '"hi"'

echo '"$USER"'

Lexer musi wiedzieÄ‡, Å¼e string w ' NIE pozwala na $, ale " tak.

4. Redirekcje bez operandÃ³w
ls >

grep <

echo hi >>

Po >, >>, <, << MUSI byÄ‡ plik (token T_WORD). Inaczej: bÅ‚Ä…d skÅ‚adni.

5. Puste polecenie po pipe
ls |

| grep hi

cat file | | grep

Pipe nie moÅ¼e byÄ‡ na poczÄ…tku, na koÅ„cu ani wystÄ™powaÄ‡ podwÃ³jnie.

6. Nieznane operatory
echo && ls

echo || ls

Te operatory sÄ… zarezerwowane w bashu, ale w minishellu ich nie obsÅ‚ugujesz, wiÄ™c musisz je odrzuciÄ‡.

7. Tokeny typu >>>, >< itp.
echo >>> file

echo >< file

Niepoprawna skÅ‚adnia redirekcji â€“ zgÅ‚oÅ› syntax error near unexpected token.

8. Puste polecenia / tylko spacje

\t\t

"\t "

Shell nie moÅ¼e siÄ™ wysypaÄ‡ ani prÃ³bowaÄ‡ wykonaÄ‡ pustego polecenia.

9. Escapeâ€™y (\) â€“ tylko w "
echo \"hello\" (w " dziaÅ‚a)

echo '\"hello\"' (w ' dziaÅ‚a literalnie)

echo \a (nie powinno dziaÅ‚aÄ‡, literalnie \a)

ObsÅ‚uga \ jest uproszczona w minishellu, ale w " warto to ogarnÄ…Ä‡ (jeÅ›li robisz bonusy).

âš ï¸ EDGE CASE'Y â€“ PARSING
1. Redirekcja w zÅ‚ym miejscu
> file echo hello

cat file.txt < in.txt > out.txt grep hi

Redirekcje muszÄ… dotyczyÄ‡ polecenia. W drugim przykÅ‚adzie grep jest niezwiÄ…zane z cat, a masz tylko jeden pipe.

2. Wiele redirekcji do tego samego strumienia
cat < a < b â€“ ostatnia wygrywa

echo hi > a > b â€“ ostatnia wygrywa

Parsuj i nadpisuj, ale zachowaj kolejnoÅ›Ä‡ do wykonania w executorze.

3. Pusta wartoÅ›Ä‡ po ekspansji
echo $EMPTY (jeÅ›li EMPTY nie istnieje)

cat "$EMPTY"

Musisz upewniÄ‡ siÄ™, Å¼e po ekspansji nie tworzysz NULL-owych tokenÃ³w ani nie rozbijasz polecenia.

4. Ekspansja w heredoc (nie w ' ')
cat << EOF z zawartoÅ›ciÄ… $USER

W heredocu typu 'EOF' nie ma ekspansji, w EOF â€“ jest.

Trzeba to uwzglÄ™dniÄ‡ przy generowaniu danych do pipe().

5. Quote w Å›rodku tokena
echo he"ll"o â†’ hello

echo he'll'o â†’ hello

Musisz skleiÄ‡ tokeny z cudzysÅ‚owami.

6. $ przed niealfanumerycznym znakiem
echo $1

echo $?

echo $

$? OK, $1 â€“ zaleÅ¼nie od implementacji, $ bez niczego â€“ literalnie $.

7. Heredoc z pustym limitem
cat <<

Brak limitera â€“ syntax error.

âœ… CO Z TYM ZROBIÄ†?
Lexer:

ObsÅ‚uÅ¼ wszystkie operatory (>, >>, <, <<, |) jako osobne tokeny.

Parsuj cudzysÅ‚owy, nie dzielÄ…c stringÃ³w w Å›rodku.

Rzucaj bÅ‚Ä™dy przy: brakujÄ…cym zamkniÄ™ciu, pustym tokenie po operatorze, nieznanym znaku.

Parser:

Rozpoznawaj i przypisuj redirekcje do wÅ‚aÅ›ciwego polecenia.

Dziel polecenia na podstawie pipeâ€™Ã³w.

Buduj t_cmd zawierajÄ…cy argv, redirekcje i inne informacje.

Waliduj skÅ‚adniÄ™.



PodzieliÅ‚em caÅ‚e wejÅ›cie na tokeny i zapisaÅ‚em je do tablicy stringÃ³w. Na przykÅ‚ad, polecenie "ls -l file | wc -w" zostanie podzielone na:
[ "ls", "-l", "file", "|", "wc", "-w" ].

IterujÄ™ po tej tablicy aÅ¼ do napotkania pipe'a (|) i dodajÄ™ kaÅ¼dy token do odpowiedniego pola w strukturze listy jednokierunkowej (linked list).
Mam strukturÄ™ t_node, ktÃ³ra zawiera zmienne:

char *cmd â€“ dla samej komendy (np. ls)

char **flags â€“ tablicÄ™ stringÃ³w na flagi (bo moÅ¼e byÄ‡ ich wiÄ™cej niÅ¼ jedna, np. -l, -a)

char **args â€“ tablicÄ™ stringÃ³w na argumenty (np. nazwy plikÃ³w itp.)

PrzechodzÄ™ przez tokeny do pierwszego pipe'a i:

ls przypisujÄ™ do cmd,

-l do tablicy flags,

file do tablicy args.
To bÄ™dzie pierwszy node (wÄ™zeÅ‚) w liÅ›cie.

NastÄ™pnie tworzÄ™ nowy wÄ™zeÅ‚ (node) dla czÄ™Å›ci po pipe'ie.
KontynuujÄ™ iteracjÄ™ po tablicy aÅ¼ do kolejnego pipe'a (albo koÅ„ca), dodajÄ…c tokeny do cmd, flags lub args, zgodnie z tÄ… samÄ… logikÄ….

Gdy caÅ‚a lista zostanie wypeÅ‚niona, zaczynam pracÄ™ nad czÄ™Å›ciÄ… odpowiedzialnÄ… za wykonywanie poleceÅ„ (execution).