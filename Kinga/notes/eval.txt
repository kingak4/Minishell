ğŸ“ CzÄ™Å›Ä‡ obowiÄ…zkowa (Mandatory Part)
ğŸ”§ Kompilacja
UÅ¼yj make -n, aby sprawdziÄ‡, czy kompilacja uÅ¼ywa flag -Wall -Wextra -Werror. JeÅ›li nie â€“ zaznacz flagÄ™ "nieprawidÅ‚owa kompilacja".

minishell kompiluje siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w. JeÅ›li nie â€“ zaznacz flagÄ™.

Makefile nie powinien przelinkowywaÄ‡ (relink). JeÅ›li tak siÄ™ dzieje â€“ zaznacz flagÄ™.

ğŸŸ¢ Proste polecenia i zmienne globalne
Uruchom proste polecenie z absolutnÄ… Å›cieÅ¼kÄ…, np. /bin/ls, bez opcji.

Ile zmiennych globalnych jest uÅ¼ywanych? Dlaczego? PoproÅ› ocenianego o podanie konkretnego przykÅ‚adu, dlaczego ich uÅ¼ycie wydaje siÄ™ konieczne lub logiczne.

Przetestuj pustÄ… komendÄ™.

Przetestuj komendy zawierajÄ…ce tylko spacje lub tabulatory.

JeÅ›li coÅ› siÄ™ zawiesza â€“ zaznacz flagÄ™ "crash".

JeÅ›li coÅ› nie dziaÅ‚a â€“ zaznacz flagÄ™ "niekompletna praca".

ğŸ§¾ Argumenty
Uruchom proste polecenie z absolutnÄ… Å›cieÅ¼kÄ… (np. /bin/ls) z argumentami, ale bez uÅ¼ycia cudzysÅ‚owÃ³w.

PowtÃ³rz wielokrotnie z rÃ³Å¼nymi poleceniami i argumentami.

ğŸ—£ï¸ echo
Uruchom echo z lub bez argumentÃ³w, z opcjÄ… -n.

Powtarzaj z rÃ³Å¼nymi argumentami.

ğŸšª exit
Uruchom exit z lub bez argumentÃ³w.

PowtÃ³rz z rÃ³Å¼nymi argumentami.

Nie zapomnij ponownie uruchomiÄ‡ minishell.

ğŸ” Kod powrotu procesu ($?)
Uruchom polecenie (np. /bin/ls), potem echo $?

SprawdÅº, czy wypisany kod zgadza siÄ™ z rzeczywistoÅ›ciÄ… (porÃ³wnaj z bash).

Przetestuj bÅ‚Ä™dne komendy (np. /bin/ls filethatdoesntexist)

SprÃ³buj np. expr $? + $?

âš ï¸ SygnaÅ‚y
Ctrl-C na pustym promptcie: powinna pojawiÄ‡ siÄ™ nowa linia i nowy prompt.

Ctrl-\ na pustym promptcie: nic siÄ™ nie powinno staÄ‡.

Ctrl-D na pustym promptcie: minishell powinien siÄ™ zamknÄ…Ä‡ â†’ uruchom ponownie.

Ctrl-C po wpisaniu tekstu: powinna pojawiÄ‡ siÄ™ nowa linia i nowy prompt, bufor ma byÄ‡ wyczyszczony.

Enter nie powinien wykonaÄ‡ starej linii.

Ctrl-D po wpisaniu czegoÅ›: nic siÄ™ nie powinno staÄ‡.

Ctrl-\ po wpisaniu czegoÅ›: nic siÄ™ nie powinno staÄ‡.

Przetestuj Ctrl-C, Ctrl-\, Ctrl-D po uruchomieniu poleceÅ„ blokujÄ…cych, np. cat, grep "coÅ›".

ğŸ“ CudzysÅ‚owy
PodwÃ³jne (")
Uruchom polecenie z argumentami i z uÅ¼yciem podwÃ³jnych cudzysÅ‚owÃ³w (testuj teÅ¼ spacje w Å›rodku).

PrzykÅ‚ad: echo "cat lol.c | cat > lol.c"

Testuj wszystko z wyjÄ…tkiem $

Pojedyncze (')
Uruchom polecenia z pojedynczymi cudzysÅ‚owami.

Testuj puste argumenty, zmienne Å›rodowiskowe, spacje, pipeâ€™y, redirekcje.

echo '$USER' powinno wypisaÄ‡ dokÅ‚adnie $USER.

Nic nie powinno byÄ‡ interpretowane.

ğŸŒ Komendy Å›rodowiskowe
env
SprawdÅº, czy env pokazuje zmienne Å›rodowiskowe.

export
Eksportuj nowe zmienne, zmieÅ„ istniejÄ…ce.

SprawdÅº wynik poleceniem env.

unset
UsuÅ„ zmienne wczeÅ›niej ustawione.

cd
ZmieÅ„ katalog roboczy, sprawdÅº, czy dziaÅ‚a (/bin/ls).

Przetestuj cd ., cd ...

pwd
Uruchom pwd w rÃ³Å¼nych katalogach.

ğŸ§­ ÅšcieÅ¼ki
ÅšcieÅ¼ka wzglÄ™dna
Uruchom komendy z uÅ¼yciem Å›cieÅ¼ek wzglÄ™dnych

Przetestuj w rÃ³Å¼nych katalogach z bardziej zÅ‚oÅ¼onÄ… strukturÄ… (np. wiele ..)

ÅšcieÅ¼ka ze zmiennej Å›rodowiskowej
Uruchom komendy bez Å›cieÅ¼ki (np. ls, wc, awk)

Unset $PATH â€“ komendy nie powinny dziaÅ‚aÄ‡

Ustaw PATH na wiele katalogÃ³w â€“ powinny byÄ‡ przeszukiwane w kolejnoÅ›ci

â¡ï¸ Redirekcje
Przetestuj <, >, >> â€“ rÃ³Å¼ne komendy i argumenty

SprawdÅº, czy ponowne redirekcje dajÄ… bÅ‚Ä…d

Przetestuj << (heredoc â€“ nie musi dodawaÄ‡ do historii)

ğŸ§ª Pipeâ€™y
cat file | grep bla | more

RÃ³Å¼ne polecenia + argumenty

NieprawidÅ‚owe komendy np. ls nieistnieje | grep bla

Mieszaj pipe'y i redirekcje

ğŸ­ â€œGo Crazyâ€ i historia
Wpisz komendÄ™, potem Ctrl-C i Enter. Bufor powinien byÄ‡ pusty.

Czy moÅ¼na poruszaÄ‡ siÄ™ po historii (strzaÅ‚ki)? Czy moÅ¼na powtÃ³rzyÄ‡ komendÄ™?

Uruchom komendy, ktÃ³re nie istniejÄ… â€“ minishell nie moÅ¼e siÄ™ zawieszaÄ‡.

cat | cat | ls powinno dziaÅ‚aÄ‡ normalnie.

SprÃ³buj dÅ‚ugiej komendy z masÄ… argumentÃ³w.

ğŸ’² Zmienne Å›rodowiskowe
echo $VAR â€“ czy zmienne sÄ… rozwijane?

"echo $USER" powinno wypisaÄ‡ wartoÅ›Ä‡ zmiennej

'echo $USER' powinno wypisaÄ‡ literalny $USER

SprawdÅº, czy USER istnieje â€“ jeÅ›li nie, ustaw go

