readline(const char *prompt)
TÅ‚umaczenie: Wczytuje jednÄ… liniÄ™ tekstu od uÅ¼ytkownika. MoÅ¼esz podaÄ‡ tekst jako zachÄ™tÄ™ (prompt), np. readline("minishell$ ");.

Zwraca: WskaÅºnik do tekstu (char *), ktÃ³ry trzeba potem samodzielnie zwolniÄ‡ free().

âœ… UÅ¼yteczne w minishell do odczytu poleceÅ„ od uÅ¼ytkownika.

add_history(char *s)
Dodaje wpis do historii poleceÅ„. DziÄ™ki temu po naciÅ›niÄ™ciu strzaÅ‚ki w gÃ³rÄ™ uÅ¼ytkownik moÅ¼e przywoÅ‚aÄ‡ poprzednie komendy.

rl_clear_history()
CzyÅ›ci caÅ‚Ä… historiÄ™ readline. UÅ¼yteczne przy koÅ„czeniu programu, Å¼eby zwolniÄ‡ pamiÄ™Ä‡.

rl_on_new_line()
Informuje readline, Å¼e przeszedÅ‚eÅ›/-aÅ› do nowej linii. NajczÄ™Å›ciej uÅ¼ywane przed ponownym wypisaniem prompta.

rl_redisplay()
OdÅ›wieÅ¼a to, co aktualnie widaÄ‡ w terminalu (np. po wyczyszczeniu ekranu albo zmianie tekstu bufora).

rl_replace_line()
Dokumentacja nieznana / trudno dostÄ™pna. Raczej niepotrzebna do podstawowych zastosowaÅ„.

ğŸ”¹ Åšrodowisko i katalogi robocze
getcwd(char *buf, size_t size)
TÅ‚umaczenie: Pobiera Å›cieÅ¼kÄ™ do aktualnego katalogu roboczego (np. /home/user/).

âœ… Przydatne do wypisywania prompta z aktualnÄ… Å›cieÅ¼kÄ….

chdir(const char *path)
Zmienia aktualny katalog roboczy (np. po komendzie cd).

Zwraca 0 przy sukcesie, -1 przy bÅ‚Ä™dzie.

getenv(const char *name)
Pobiera wartoÅ›Ä‡ zmiennej Å›rodowiskowej (np. getenv("HOME") â†’ /home/user).

âœ… Potrzebne do obsÅ‚ugi Å›cieÅ¼ek, np. w cd bez argumentÃ³w.

ğŸ”¹ Pliki i katalogi
stat(), lstat(), fstat()
PobierajÄ… informacje o pliku: rozmiar, typ, prawa dostÄ™pu itd.

RÃ³Å¼nice:

stat(): zwykÅ‚y plik

lstat(): dziaÅ‚a rÃ³wnieÅ¼ na symlinkach

fstat(): dziaÅ‚a na deskryptorach plikÃ³w (int fd)

opendir(const char *name)
Otwiera katalog i zwraca wskaÅºnik do struktury DIR.

readdir(DIR *dirp)
Odczytuje kolejnÄ… pozycjÄ™ z katalogu (np. kolejny plik).

closedir(DIR *dirp)
Zamyka otwarty wczeÅ›niej katalog.

âœ… MoÅ¼esz ich uÅ¼yÄ‡ przy implementacji ls albo przy szukaniu plikÃ³w wykonywalnych.

ğŸ”¹ BÅ‚Ä™dy
strerror(int errnum)
Zwraca opis bÅ‚Ä™du odpowiadajÄ…cego kodowi errnum (np. strerror(errno)).

perror(const char *s)
Wypisuje komunikat o bÅ‚Ä™dzie poprzedzony Twoim tekstem.

âœ… Åšwietne do debugowania: perror("open failed")

ğŸ”¹ Terminale i urzÄ…dzenia
isatty(int fd)
Sprawdza, czy deskryptor fd to terminal (np. isatty(0) sprawdza stdin).

ttyname(int fd)
Zwraca nazwÄ™ terminala przypisanego do deskryptora (np. /dev/pts/0).

ttyslot()
Funkcja starsza, zwraca numer terminala. Rzadko potrzebna, raczej legacy.

ioctl(int fd, unsigned long request, ...)
OgÃ³lna funkcja do manipulowania urzÄ…dzeniami. Bardziej zaawansowana.

ğŸ”¹ Tryb terminala (np. surowy tryb do obsÅ‚ugi sygnaÅ‚Ã³w, inputu)
tcgetattr(int fd, struct termios *termios_p)
Pobiera aktualne ustawienia terminala (np. echo, kanonicznoÅ›Ä‡ itp.)

tcsetattr(int fd, int optional_actions, const struct termios *termios_p)
Ustawia nowe parametry terminala.

âœ… UÅ¼ywane np. do wyÅ‚Ä…czenia echo podczas wpisywania hasÅ‚a lub do obsÅ‚ugi ctrl+C, ctrl+D.

ğŸ”¹ Biblioteka termcap (obsÅ‚uga terminali, formatowania)
tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs
Funkcje do obsÅ‚ugi parametrÃ³w terminala (kolorowanie, przesuwanie kursora itp.)

â— Bardziej zaawansowane, ale mogÄ… siÄ™ przydaÄ‡ np. do czyszczenia ekranu, kolorÃ³w prompta.

âœ… Podsumowanie â€“ ktÃ³re funkcje najwaÅ¼niejsze do minishell:
Funkcja	Do czego uÅ¼yjesz
readline()	Wczytywanie komendy uÅ¼ytkownika
add_history()	ZapamiÄ™tywanie poprzednich komend
getcwd()	Wypisywanie aktualnej Å›cieÅ¼ki w promptcie
chdir()	ObsÅ‚uga cd
getenv()	Pobieranie Å›cieÅ¼ek jak HOME, PATH
stat()	Sprawdzanie, czy plik istnieje i jest wykonywalny
opendir() / readdir()	Szukanie plikÃ³w w folderach (PATH)
perror()	Wypisywanie bÅ‚Ä™dÃ³w
isatty()	Sprawdzenie, czy wejÅ›cie to terminal
tcgetattr() / tcsetattr()	Zaawansowana obsÅ‚uga terminala i sygnaÅ‚Ã³w



ğŸ§  PARSING (analiza wejÅ›cia uÅ¼ytkownika)
Tutaj chodzi o:

odczyt linii poleceÅ„,

podziaÅ‚ na komendy, argumenty,

obsÅ‚ugÄ™ zmiennych Å›rodowiskowych ($HOME, $? itd.),

sprawdzanie, czy sÄ… pipe'y, redirekcje itp.

ğŸ”¹ Funkcje przydatne do PARSINGU:
Funkcja	Do czego siÄ™ przyda
readline()	Wczytanie wejÅ›cia uÅ¼ytkownika jako string
add_history()	Zapisanie komendy do historii
rl_clear_history()	(opcjonalnie) czyszczenie historii
getenv()	Rozwijanie zmiennych Å›rodowiskowych (np. $PATH)
getcwd()	Rozwijanie pwd lub $PWD w zmiennych
isatty()	Sprawdzenie, czy to terminal (opcjonalnie w parsing shell-scripts)
strerror() / perror()	Diagnostyka bÅ‚Ä™dÃ³w przy analizie (np. niezamkniÄ™ty cudzysÅ‚Ã³w)

Dodatkowo, w parsingu piszesz wÅ‚asne funkcje:

lexer/tokenizer (rozdzielanie sÅ‚Ã³w, operatorÃ³w |, <, >)

parser (Å‚Ä…czenie tokenÃ³w w struktury typu AST lub lista komend)
